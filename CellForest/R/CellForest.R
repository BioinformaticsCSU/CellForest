#' CellForest
#'
#' Cluster samples based on functional similarity using gene-set based local similarity
#' @param data  A expression data matrix,gene in rows and samples in columns.
#' @param kcluster  The number of clusters to output.
#' @param ncores The number of cores to be used when the program running in parallel. When set to -1, the number of cores to use is n-1 where n is the total number of cores.
#' @return geneImportance The weights of genes calculated by function randomForest.
#' @return CM similarity matrix calculated by Cell Forest.
#' @return cluster predicated clusters by using CM and Hierarchical Clustering.
#' @return randomGrank Noise distribution generated by random labels.
#' @return sampleLabelRes Statistics of changes in the four thresholds.
#' @return nselgenes The number of selected genes.
#' @return selgeneratio Proportion of selected genes.
#' @return time Program running time.
#' @keywords clustering, unsupervised feature selection
#' @export
#' @author Hongdong Li, lhdcsu@gmail.com, Central South University.
#' @examples
#' data(CFDemo)
#' result = CellForest(data,kcluster = kprior)
#' performance = evalcluster(label,result$cluster)


CellForest<-function(data,kcluster,ncores=-1){
  timestart <- proc.time()
  nperm = 1
  rep = 1
  thresholdMethod="meansd"
  method=c("imp")
  N=1
  toppct=1
  minprob=0.3
  rgene=-1
  labelknown=NULL
  errorrate=NULL
  clustermethod=c("SC3","kmeans")
  randomlabel=F
  pctgenes=-1

  library(foreach)
  library(doParallel)
  if (ncores==-1){ncores=detectCores()-1}
  if (length(method)==1){method=method[1]}
  if (length(clustermethod)>1) {clustermethod="sc3"}
  clustermethod=tolower(clustermethod)

  nsample=ncol(data)
  ngene=nrow(data)
  # if (max(toppct) > ngene){kc=which(toppct>ngene)[1]; toppct=toppct[1:(kc-1)]}
  geneweight0=rep(0,length=ngene)
  names(geneweight0)=rownames(data)



  ################################################################
  ################################################################
  ############# decide how to generate random gene sub-space
  ################################################################
  if (rgene<=0){  # equally divide: K-fold CV
    # divide genes in N groups randomly
    group=c(1:ngene-1) %% N +1
    rand_index=sample(group)
  }else{  # ranomly sampling: like MCCV
    Q=floor(ngene*rgene)
  }


  # Main
  # prepare data for parallelization
  # print(labelknown)
  # print(errorrate)
  DATA=list()
  LABEL=list()
  cat("Gene subset sampling...","\n")
  for (j in 1:N){

    # step 1: generate sub-datasets
    if (rgene>0){
      subseti=sample(ngene,Q)
      Xi=t(data[subseti,])
    }else{
      if(N == 1){
        subseti=which(rand_index==j)
        Xi=t(data[subseti,])
      }else{
        subseti=which(rand_index!=j)
        Xi=t(data[subseti,])
      }
    }


    # step 2: generate labels by clustering anlaysis
    if (!is.null(labelknown) && !is.null(errorrate)){
      plabel=gen_errorlabel(labelknown,errorrate)
      print("error label used")

    }else{
      if (clustermethod=="sc3"){
        cmi=sc3cm(t(Xi),kcluster,verbose=0)
      }else if (clustermethod=="kmeans"){
        cmi=cluster2cm(kmeans(Xi,kcluster)$cluster)
      }else if (clustermethod=="hclust"){
        cmi=cluster2cm(hc(Xi,kcluster))
      }
      plabel=hc(cmi,kcluster)
    }



    # step 3: whether to further randomize labels
    if (randomlabel){
      plabel=sample(plabel)
    }


    #step 4: record sub-datasets and cell labels
    DATA[[j]]=Xi
    LABEL[[j]]=plabel
  }

  # run Feature selection
  cat("Run randomForest for feature selection.\n")


  # myCluster <- makeCluster(ncores)
  # registerDoParallel(myCluster)
  # task=1:nperm
  # randomGrank <- foreach(j = task,.combine="rbind",.packages = "randomForest") %dopar% {
  #   randomLabel = sample(LABEL[[1]])
  #   rfRandom=randomForest(DATA[[1]],factor(randomLabel),importance = T)
  #   grank=rfRandom$importance[,kcluster+1]
  #   wj=geneweight0
  #   wj[names(grank)]=grank
  #   wj
  # }
  # stopCluster(myCluster)

  randomGrank=geneweight0
  for (i in 1:nperm) {
    randomLabel = sample(LABEL[[1]])
    rfRandom=randomForest(DATA[[1]],factor(randomLabel),importance = T)
    grank=rfRandom$importance[,kcluster+1]
    wj=geneweight0
    wj[names(grank)]=grank
    randomGrank=rbind(randomGrank,wj)
  }


  sampleLabelRes=data.frame(row.names = c("max","mean","sd","Uquartile"))
  if(nperm==1){
    maxT=randomGrank[which.max(randomGrank)]
    mean=mean(randomGrank)
    sd=sd(randomGrank)
    Uquartile=quantile(randomGrank, probs = 0.75)
    temp = as.data.frame(c(maxT,mean,sd,Uquartile))
    sampleLabelRes=cbind(sampleLabelRes,temp)
  }else{
    for (i in 1:nperm) {
      maxT=randomGrank[i,which.max(randomGrank[i,])]
      mean=mean(randomGrank[i,])
      sd=sd(randomGrank[i,])
      Uquartile=quantile(randomGrank[i,], probs = 0.75)
      temp = as.data.frame(c(maxT,mean,sd,Uquartile))
      sampleLabelRes=cbind(sampleLabelRes,temp)
    }
  }
  maxT=mean(as.numeric(sampleLabelRes[1,]))
  msdT=mean(as.numeric(sampleLabelRes[2,])) + 3*mean(as.numeric(sampleLabelRes[3,]))
  Uquartile=mean(as.numeric(sampleLabelRes[4,]))

  myCluster <- makeCluster(ncores)
  registerDoParallel(myCluster)
  task=1:rep
  geneweight <- foreach(j = task,.combine="rbind",.packages = "randomForest") %dopar% {
    rf=randomForest(DATA[[1]],factor(LABEL[[1]]),importance = T)
    grank=rf$importance[,kcluster+1]
    # if(thresholdMethod == "zero"){
    #   goodgenes=names(grank[grank>0])
    # }else if(thresholdMethod == "max"){
    #   goodgenes=names(grank[grank>maxT])
    # }else if(thresholdMethod == "meansd"){
    #   goodgenes=names(grank[grank>msdT])
    # }
    # grank = grank[goodgenes]
    wj=geneweight0
    wj[names(grank)]=grank
    wj
  }
  stopCluster(myCluster)

  geneweight0=geneweight
  if(rep!=1){
    geneweight=colSums(geneweight)/(rep)
  }
  if(thresholdMethod == "zero"){
    goodgenes=names(geneweight[geneweight>0])
    minprob = 0
  }else if(thresholdMethod == "max"){
    goodgenes=names(geneweight[geneweight>maxT])
    minprob = maxT
  }else if(thresholdMethod == "meansd"){
    goodgenes=names(geneweight[geneweight>msdT])
    minprob = msdT
  }else if(thresholdMethod == "UpperQuartile"){
    goodgenes=names(geneweight[geneweight>Uquartile])
    minprob = Uquartile
  }

  # if (N!=1){
  #   geneweight=colSums(geneweight)/(N-1)
  # }

  # find optimal genes
  if(pctgenes>0){
    nselgenes=round(ngene*pctgenes)
  }else{
    nselgenes = length(goodgenes)
  }

  selgeneratio = length(nselgenes)/ngene

  if(method=="freq"){
    cat(nselgenes,' genes with freq >= ',minprob,'\n')
  }else{
    cat(nselgenes,' genes with imp >= ',minprob,'\n')
  }

  if(nselgenes<10){
    return(list(cluster = rep(1,nsample),geneImportance=geneweight0,nselgenes = nselgenes,selgeneratio = selgeneratio))
  }

  cat("Gene subset evaluation.\n")
  geneweight=geneweight[order(-geneweight)]


  CMall=list()
  CMavg=matrix(0,nsample,nsample)
  clusters=list()
  for (g in 1:length(toppct)){
    # cat("Evaluate the top ",toppct[g]*100,"% genes","\n")
    optgenes=names(geneweight[1:floor(nselgenes*toppct[g])])
    cmg=sc3cm(data[optgenes,],kcluster,verbose=0)


    plabel=hc(cmg,kcluster)
    clusters[[g]]=plabel


    CMall[[g]]=cmg
    CMavg=CMavg+cmg
  }
  CMavg=CMavg/length(toppct)
  cluster=hc(CMavg,kcluster)
  runningtime <- proc.time() - timestart
  return(list(randomGrank=randomGrank,sampleLabelRes=sampleLabelRes,geneImportance=geneweight0,nselgenes = nselgenes,selgeneratio = selgeneratio,CM=CMavg,LABEL=LABEL,cluster=cluster,CMall=CMall,clusterall=clusters,toppct=toppct,minprob=minprob,N=N,kcluster=kcluster,clustermethod=clustermethod,time=runningtime))
}

gen_errorlabel<-function(labelknown,errorrate){
  # basic
  n=length(labelknown)
  labelerror=labelknown
  nr=round(n*errorrate)
  ulabel=unique(labelknown)
  randindex=sample(n,nr)
  # if (nr<1){nr=1}


  # randomize label
  if(nr==1) {
    rlabel=sample(setdiff(ulabel,labelknown[randindex]),1)
    labelerror[randindex]=rlabel

  }else if (nr>1){
    labelerror[randindex]=sample(labelerror[randindex])
  }
  return(labelerror)
}



sc3cm<-function(X,kcluster,nstart=1000,niter=1e9,verbose=1){
  # Obtain a consensus matrix generated by the SC3 method.
  # X: A expression data matrix,gene in rows and samples in columns.
  # kcluster: The number of clusters to output.
  # nstart: nstart parameter passed to kmeans function. Can be set manually. Default: 1000.
  # niter: iter.max parameter passed to kmeans function. Default: 1e9.
  # verbose: defines whether to output the operation being performed at the console.

  # library(foreach)
  # library(doParallel)

  ncores=detectCores()-1
  # d-region
  nsample=ncol(X)

  if(nsample>2000)
    nstart = 50

  nregion=floor(nsample*0.04):ceiling(nsample*0.07)
  nregion=nregion[which(nregion>=2)]
  if (length(nregion)==0){nregion=2}
  if (length(nregion)>15){nregion=sample(nregion,15)}


  # distance matrix
  D=list()
  D[[1]]=as.matrix(compute_dist(X,"euclidean"))
  D[[2]]=as.matrix(compute_dist(X,"spearman"))
  D[[3]]=as.matrix(compute_dist(X,"pearson"))


  # MATRIX decomposition
  grid0=expand.grid(1:length(D),1:2)
  myCluster <- makeCluster(ncores)
  registerDoParallel(myCluster)
  task=1:nrow(grid0)
  # print(grid0)
  DL0=list()
  DL0 <- foreach(j = task, .export=c("pca","calLaplacian")) %dopar% {
    # source("/Users/hdl/Documents/Study/mypaper/carf/code/subroutines.R")
    # library(SC3)
    igrid=grid0[j,]
    dim1=as.numeric(igrid[1])
    dim2=as.numeric(igrid[2])
    if (dim2==1){
      U=pca(D[[dim1]],scale = TRUE)
    }else if (dim2 == 2){
      U=calLaplacian(D[[dim1]])
    }
    U
  }
  stopCluster(myCluster)
  iter=1
  DL=list()
  for (j in 1:length(DL0)){
    if (is.matrix(DL0[[j]]))  {DL[[iter]]=DL0[[j]]; iter=iter+1} }


  # consensus
  if (verbose==1) {print("SC3: calculating consensus matrix")}
  myCluster <- makeCluster(ncores)
  registerDoParallel(myCluster)
  grid=expand.grid(1:length(DL),nregion)
  # print(grid)
  task=1:nrow(grid)
  CM <- foreach(j = task,.combine="+",.export = "cluster2cm") %dopar% {
    # library(cluster)
    jgrid=grid[j,]
    dim1=as.numeric(jgrid[1])
    dim2=as.numeric(jgrid[2])
    # source("/Users/hdl/Documents/Study/mypaper/carf/code/subroutines.R")
    clustj=kmeans(DL[[dim1]][,1:dim2],kcluster,iter.max=niter,nstart=nstart)$cluster
    CMj=cluster2cm(clustj)
  }
  CM=CM/max(CM)
  stopCluster(myCluster)
  if (verbose==1) {print("SC3: done")}

  CM=CM/max(CM)
  return(CM)
}

compute_dist<-function(X,distmethod=c("pearson","euclidean","spearman")){
  # calculate distance between columns
  # X: A expression data matrix,gene in rows and samples in columns.

  if (distmethod %in% c("pearson","spearman")){
    corr = cor(X,method=distmethod)
    D=as.dist(1-corr)
  }else if(distmethod == "euclidean"){
    D=as.dist(dist(t(X),method=distmethod))
  }
  return(D)
}

pca<-function(X,scale=TRUE){
  #pca
  pc=try(prcomp(X,scale=scale),silent=TRUE)
  if ("rotation" %in% names(pc)){
    scores=pc$rotation
  }else{
    scores="none"
  }
  return(scores)
}

calLaplacian<-function(dists){
  # L <- norm_laplacian(dists)
  # L <- laplacian(dists)
  A = dists
  A = exp(-A/max(A))
  D_row = diag(x=apply(A,1,sum)^-0.5)
  D_col = diag(x=apply(A,2,sum)^-0.5)
  L = diag(x=1,ncol(A),ncol(A)) - D_row%*%A%*%D_col
  l <- eigen(L)
  # sort eigenvectors by their eigenvalues
  D=l$vectors[, order(l$values)]
  return(D)
}

cluster2cm<-function(cluster){
  # convert cluster vector to a consensus matrix
  uc=unique(cluster)
  n=length(cluster)
  CM=matrix(0,n,n)
  for (v in uc){
    kv=which(cluster==v)
    CM[kv,kv] = 1
  }
  return(CM)
}

hc<-function(X,k){
  #Hierarchical Clustering
  # tree=hclust(dist(X))
  tree=hclust(as.dist(1-X))
  cluster = cutree(tree,k)

  return(cluster)
}

#' evalcluster
#'
#' Three criteria (NMI, RI, ARI) to evaluate clustering performance.
#' @param truelabel A numeric vector of true labels of each sample.
#' @param predlabel A numeric vector of predicted labels of each sample.
#' @return NMI Value of normalized mutual information.
#' @return RI Value of rand index.
#' @return ARI Value of adjusted rand index.
#' @examples
#' truelabel = sample(1:3, size=10, replace=TRUE)
#' predlabel = sample(1:3, size=10, replace=TRUE)
#' evalcluster(truelabel,predlabel)


evalcluster<-function(truelabel,predlabel){
  if(length(truelabel)!=length(predlabel))
    stop("truelabel and predlabel must have the same length")
  total = length(truelabel)
  x_ids = unique(truelabel)
  y_ids = unique(predlabel)
  #Mutual information
  MI = 0.0
  for(idx in x_ids){
    for(idy in y_ids){
      idxOccur = which(truelabel==idx)
      idyOccur = which(predlabel==idy)
      idxyOccur = intersect(idxOccur,idyOccur)
      if(length(idxyOccur)>0){
        MI = MI + (length(idxyOccur)/total)*log2((length(idxyOccur)*total)/(length(idxOccur)*length(idyOccur)));
      }
    }
  }

  #Normalized Mutual information
  Hx = 0; #Entropies
  for(idx in x_ids){
    idxOccurCount = length(which(truelabel==idx));
    Hx = Hx - (idxOccurCount/total) * log2(idxOccurCount/total);
  }
  Hy = 0;#Entropies
  for(idy in y_ids){
    idyOccurCount = length(which(predlabel==idy));
    Hy = Hy - (idyOccurCount/total) * log2(idyOccurCount/total);
  }
  nmi = 2 * MI / (Hx+Hy)

  #(adjusted) Rand Index
  tab = table(truelabel,predlabel)
  conv_df = as.data.frame.matrix(tab)
  n <- sum(tab)
  ni <- apply(tab, 1, sum)
  nj <- apply(tab, 2, sum)
  n2 <- choose(n, 2)
  nis2 <- sum(choose(ni[ni > 1], 2))
  njs2 <- sum(choose(nj[nj > 1], 2))
  ri = 1 + (sum(tab^2) - (sum(ni^2) + sum(nj^2))/2)/n2
  ari=c(sum(choose(tab[tab > 1], 2)) - (nis2 * njs2)/n2)/((nis2 + njs2)/2 - (nis2 * njs2)/n2)

  out = c(nmi,ri,ari)
  names(out)=c("NMI","RI","ARI")
  return(out)
}


